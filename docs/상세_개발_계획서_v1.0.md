# 한국 은행 개인 신용평가 시스템 (KCS)
# 상세 개발 계획서 (Development Master Plan)

**문서 번호**: KCS-DMP-2026-001
**버전**: v1.0
**작성일**: 2026-02-27
**참조 요건**: KCS-SRS-2026-001 (상세 요건 정의서 v1.0)
**총 개발 기간**: 12개월 (2026-04-01 ~ 2027-03-31)

---

## 목차

1. [개발 전략 및 방법론](#1-개발-전략-및-방법론)
2. [팀 구성 및 역할](#2-팀-구성-및-역할)
3. [기술 스택 결정](#3-기술-스택-결정)
4. [개발 환경 구성](#4-개발-환경-구성)
5. [단계별 개발 계획](#5-단계별-개발-계획)
6. [컴포넌트별 상세 구현 계획](#6-컴포넌트별-상세-구현-계획)
7. [데이터베이스 설계 계획](#7-데이터베이스-설계-계획)
8. [ML 파이프라인 상세 계획](#8-ml-파이프라인-상세-계획)
9. [외부 연동 구현 계획](#9-외부-연동-구현-계획)
10. [보안 구현 계획](#10-보안-구현-계획)
11. [테스트 실행 계획](#11-테스트-실행-계획)
12. [배포 및 운영 이관 계획](#12-배포-및-운영-이관-계획)
13. [리스크 관리 계획](#13-리스크-관리-계획)
14. [WBS 및 마일스톤](#14-wbs-및-마일스톤)
15. [품질 관리 계획](#15-품질-관리-계획)

---

## 1. 개발 전략 및 방법론

### 1.1 핵심 개발 원칙

> **"규제 준수는 코드로 증명한다"**
> 모든 규제 요건은 자동화 테스트로 검증 가능해야 하며, 사람의 수동 확인에 의존하지 않는다.
> **"측정할 수 없으면 개선할 수 없다"**
> 모든 컴포넌트는 배포 첫날부터 모니터링 지표를 생성해야 한다.

### 1.2 방법론: 구조적 반복 개발 (Structured Iterative)

순수 폭포수(Waterfall)는 요건 변경에 취약하고, 순수 애자일은 금융 규제 준수 산출물 관리에 불리하다. 두 방법론의 장점을 결합한다.

```
[전체 구조: Phase 기반 Waterfall]
Phase 1 → Phase 2 → Phase 3 → Phase 4 → Phase 5 → Phase 6
  (각 Phase 완료 후 은행 검수 및 대금 지급)

[Phase 내부: 2주 스프린트 반복]
Sprint 계획 → 개발 → 코드 리뷰 → 자동 테스트 → Sprint 리뷰
  (스프린트마다 동작하는 컴포넌트 산출, 지속적 피드백)

[품질 게이트: Phase 전환 조건]
  각 Phase 종료 시 품질 게이트 통과 후에만 다음 Phase 진입 가능
  품질 게이트 미달 시 → 해당 Phase 내에서 재작업 (일정 예비비 활용)
```

### 1.3 개발 우선순위 결정 원칙

```
[우선순위 1] 규제 하드컷 로직 (DSR, LTV, 최고금리, CB 동의)
  → 이것이 틀리면 법적 위반. 가장 먼저, 가장 철저히 구현.

[우선순위 2] 신청자 유형 판별 + 모델 라우팅
  → 이것이 틀리면 모든 평가 결과가 무의미.

[우선순위 3] 신용평가 코어 엔진 (모델 추론 + 점수 스케일링)
  → 시스템의 핵심 비즈니스 가치.

[우선순위 4] 한도/금리 산출 (EQ, IRG, 스트레스 DSR)
  → 수익성의 직접 레버.

[우선순위 5] 감사 로그 + RBAC + 보안
  → 규제 준수의 증거 체계.

[우선순위 6] 모니터링 + 보고서 + UX
  → 운영 효율 및 감독 대응.
```

### 1.4 코드 품질 기준 (배포 불가 조건)

다음 조건 중 하나라도 해당하면 main 브랜치 병합 불가:

```
□ 단위 테스트 커버리지 < 80%
□ 규제 준수 테스트 케이스 1건 이상 실패
□ Ruff 린트 오류 존재
□ Mypy 타입 오류 존재
□ Bandit 보안 정적 분석 High 이상 오류 존재
□ PR 리뷰어 미승인 (최소 2인 리뷰)
```

---

## 2. 팀 구성 및 역할

### 2.1 프로젝트 조직도

```
[은행 측 (발주처)]
여신사업총괄 (프로젝트 오너)
    │
    ├── PM (은행 측) ─────────────── PM (SI 업체 측)
    │                                      │
    ├── 업무 요건 담당 (영업점·심사팀)      │
    ├── 컴플라이언스 담당                   │
    └── IT 기획 담당                       │
                                    ┌──────┴──────────────────┐
                                    │      SI 개발팀           │
                                    ├─ 아키텍처 리드 (1)
                                    ├─ ML 엔지니어 (3)
                                    ├─ 백엔드 개발자 (4)
                                    ├─ DB 엔지니어 (1)
                                    ├─ DevOps/인프라 (2)
                                    ├─ 보안 전문가 (1)
                                    └─ QA 엔지니어 (2)
```

### 2.2 역할별 책임 정의 (RACI)

| 작업 항목 | 아키텍처 리드 | ML 엔지니어 | 백엔드 개발자 | DB 엔지니어 | DevOps | 보안 | QA | 은행 측 PM |
|---------|:-----------:|:----------:|:-----------:|:----------:|:------:|:----:|:--:|:---------:|
| 아키텍처 설계 확정 | **R** | C | C | C | C | C | I | **A** |
| ML 모델 개발·검증 | C | **R** | I | I | I | I | **A** | A |
| 규제 하드컷 구현 | C | I | **R** | I | I | I | **A** | **A** |
| DB 스키마 설계 | C | I | C | **R** | I | C | I | A |
| API 개발 | I | I | **R** | C | I | C | A | I |
| 외부 연동 (CB/CBS) | C | I | **R** | I | C | C | A | A |
| 보안 구현 | C | I | C | C | C | **R** | **A** | A |
| CI/CD 파이프라인 | C | I | C | I | **R** | C | I | I |
| 규제 준수 테스트 | I | I | I | I | I | I | **R** | **A** |
| UAT 수행 | I | I | I | I | I | I | C | **R** |
| 운영 이관 | C | C | C | C | **R** | C | C | **A** |

> R=Responsible, A=Accountable, C=Consulted, I=Informed

### 2.3 핵심 인력 역량 요건

**ML 엔지니어 (Lead)**
- LightGBM/XGBoost 실무 경험 3년 이상
- SHAP 설명 가능성 구현 경험
- 금융 신용평가 모델 개발 경험 우대
- WOE/IV 기반 피처 엔지니어링 경험

**백엔드 개발자 (Lead)**
- FastAPI + SQLAlchemy 실무 2년 이상
- 금융 시스템 비동기 처리 경험
- PostgreSQL 고성능 쿼리 최적화 경험
- 외부 API 연동 (CB, 공공 API) 경험

**보안 전문가**
- 금융보안원 가이드라인 이해
- OWASP Top 10 취약점 진단 경험
- 개인정보 보호법·신용정보법 실무 이해

---

## 3. 기술 스택 결정

### 3.1 기술 스택 선정 및 근거

```
[백엔드 API]
FastAPI 0.110+           이유: 비동기 처리 성능, 자동 Swagger 생성, 타입 안전성
Pydantic v2              이유: 입력 검증 + 자동 직렬화, 규제 파라미터 유효성 검사
SQLAlchemy 2.0 (async)   이유: 비동기 DB 세션, ORM + Core 혼용 가능
Alembic                  이유: DB 마이그레이션 버전 관리 (규제 변경 추적)
python-jose              이유: JWT RS256 서명 (HS256보다 보안성 높음)

[ML 파이프라인]
LightGBM 4.x            이유: 빠른 추론 속도, 범주형 변수 직접 처리, 메모리 효율
XGBoost 2.x             이유: Behavioral Scorecard (LightGBM 챌린저 역할도 수행)
scikit-learn 1.4+       이유: 전처리 파이프라인, 모델 평가 지표
SHAP 0.44+              이유: TreeExplainer 속도 최적화, Top-K 계산
joblib                  이유: 모델 직렬화, 병렬 피처 계산

[데이터베이스]
PostgreSQL 16            이유: JSON 지원, 감사 로그 파티셔닝, 성숙도
Redis 7.x                이유: 세션 캐시, EQ Grade DB 캐시, 금리 파라미터 캐시
asyncpg                  이유: 비동기 PostgreSQL 드라이버 (성능 최우선)

[메시지 큐]
Apache Kafka 3.6+        이유: 감사 로그 at-least-once 보장, 높은 처리량
                               (RabbitMQ는 at-least-once 보장이 설정 복잡)

[인프라]
Docker + Docker Compose  이유: 환경 일관성, 로컬/스테이징/운영 동일 구성
Nginx                    이유: API Gateway 역할, TLS 종단, Rate Limiting
Prometheus + Grafana     이유: 실시간 지표 수집·시각화 (금감원 PSI 대시보드)
Elasticsearch + Kibana   이유: 감사 로그 전문 검색 (감사팀 로그 조회)

[CI/CD]
GitHub Actions           이유: PR 기반 자동 테스트, 배포 파이프라인
pytest 8.x               이유: 규제 준수 자동 테스트 프레임워크
ruff                     이유: 린트 + 포매터 (flake8 대체, 속도 100x)
mypy                     이유: 타입 검사 (금융 계산 오류 사전 방지)
bandit                   이유: 보안 정적 분석
```

### 3.2 의존성 관리 원칙

```
[고정 원칙]
- 모든 의존성은 requirements.txt에 버전 핀(pin) 고정
  예) lightgbm==4.3.0  (>=4.0은 불가 — 암묵적 업그레이드 방지)
- 신규 라이브러리 추가 시 보안팀 검토 필수
- GPL 계열 라이선스 사용 금지 (MIT/Apache/BSD만 허용)
- 외부 의존성 개수 최소화 (fat library 경계)
```

### 3.3 디렉토리 구조 최종 확정

```
korea-credit-scoring/
│
├── backend/
│   ├── app/
│   │   ├── main.py                     ← FastAPI 앱 진입점
│   │   ├── config.py                   ← 설정 (규제 파라미터 포함)
│   │   ├── api/
│   │   │   └── v1/
│   │   │       ├── router.py           ← 라우터 통합
│   │   │       ├── scoring.py          ← POST /score
│   │   │       ├── applications.py     ← 신청 CRUD
│   │   │       ├── monitoring.py       ← PSI/RAROC
│   │   │       ├── admin.py            ← 파라미터 관리
│   │   │       └── reports.py          ← 보고서 생성
│   │   ├── core/
│   │   │   ├── scoring_engine.py       ← 평가 오케스트레이터
│   │   │   ├── applicant_classifier.py ← 신청자 유형 판별
│   │   │   ├── feature_engineering.py  ← 유형별 피처 생성
│   │   │   ├── model_registry.py       ← 모델 로딩/버전 관리
│   │   │   └── limit_calculator.py     ← 한도 산출 (EQ/IRG)
│   │   ├── compliance/
│   │   │   ├── hard_cut_engine.py      ← 규제 하드컷 (DSR/LTV/최고금리)
│   │   │   ├── stress_dsr.py           ← 스트레스 DSR 계산
│   │   │   ├── explanation_engine.py   ← SHAP→한국어 변환
│   │   │   ├── fairness_monitor.py     ← 공정성 + PSI 3종
│   │   │   ├── consent_manager.py      ← CB 동의 관리
│   │   │   └── audit_logger.py         ← Kafka 감사 로그
│   │   ├── pricing/
│   │   │   ├── pricing_engine.py       ← 금리 산출
│   │   │   └── risk_parameters.py      ← PD/LGD/EAD/RW 파라미터
│   │   ├── employer/
│   │   │   ├── eq_grade_service.py     ← EQ 등급 조회/관리
│   │   │   └── eq_grade_db.py          ← EQ 등급 내부 DB 연동
│   │   ├── industry/
│   │   │   └── irg_mapping_service.py  ← KSIC → IRG 매핑
│   │   ├── security/
│   │   │   ├── rbac.py                 ← 역할 기반 접근 제어
│   │   │   ├── crypto.py               ← HMAC-SHA256 + AES-256
│   │   │   └── jwt_handler.py          ← RS256 JWT 처리
│   │   ├── db/
│   │   │   ├── base.py
│   │   │   ├── session.py
│   │   │   └── schemas/                ← ORM 모델 (15개 테이블)
│   │   ├── monitoring/
│   │   │   ├── psi_calculator.py       ← PSI 3종 계산
│   │   │   ├── raroc_calculator.py     ← RAROC 산출
│   │   │   └── alert_service.py        ← 임계값 초과 알림
│   │   └── external/
│   │       ├── cb_client.py            ← CB API 클라이언트
│   │       ├── cbs_client.py           ← CBS 연동
│   │       ├── nts_client.py           ← 국세청 홈택스 API
│   │       └── employer_api_client.py  ← 기업신용정보 API
│   ├── alembic/                        ← DB 마이그레이션
│   ├── Dockerfile
│   └── requirements.txt
│
├── ml_pipeline/
│   ├── data/
│   │   ├── synthetic_data.py           ← 유형별 합성 데이터 생성
│   │   └── preprocessor.py             ← 실제 데이터 전처리
│   ├── training/
│   │   ├── base_trainer.py             ← 공통 학습 베이스 클래스
│   │   ├── train_application_salaried.py  ← 직장인 Application Scorecard
│   │   ├── train_application_business.py  ← 개인사업자 Application Scorecard
│   │   ├── train_application_pensioner.py ← 연금소득자 Application Scorecard
│   │   ├── train_behavioral.py         ← Behavioral Scorecard
│   │   └── train_collection.py         ← Collection Scorecard
│   ├── validation/
│   │   ├── oot_validator.py            ← OOT 검증
│   │   ├── fairness_validator.py       ← 공정성 검증
│   │   └── champion_challenger.py      ← Shadow 운영 성과 비교
│   └── artifacts/
│       ├── application_salaried/
│       ├── application_business/
│       ├── application_pensioner/
│       ├── behavioral/
│       └── collection/
│
├── validation/
│   └── roles/
│       ├── developer/
│       │   └── test_model_performance.py
│       ├── risk_management/
│       │   └── test_risk_profitability.py
│       ├── internal_audit/
│       │   └── test_regulatory_compliance.py  ← 신규 작성 필요
│       └── regulatory/
│           └── test_regulatory_validation.py  ← 신규 작성 필요
│
├── tests/
│   ├── unit/
│   │   ├── test_hard_cut_engine.py
│   │   ├── test_stress_dsr.py
│   │   ├── test_limit_calculator.py
│   │   ├── test_pricing_engine.py
│   │   ├── test_applicant_classifier.py
│   │   ├── test_eq_grade_service.py
│   │   ├── test_irg_mapping.py
│   │   ├── test_explanation_engine.py
│   │   └── test_crypto.py
│   ├── integration/
│   │   ├── test_scoring_api.py
│   │   ├── test_cb_integration.py
│   │   └── test_audit_log_integrity.py
│   └── regulatory/
│       ├── test_dsr_hard_cut.py        ← TC-REG-001~005
│       ├── test_ltv_hard_cut.py        ← TC-REG-006
│       ├── test_minor_rejection.py     ← TC-REG-007
│       ├── test_cb_consent.py          ← TC-REG-008
│       ├── test_tax_delinquency.py     ← TC-REG-009
│       ├── test_max_rate.py            ← TC-REG-010
│       ├── test_multi_home.py          ← TC-REG-011
│       ├── test_business_age.py        ← TC-REG-012
│       ├── test_rejection_reason.py    ← TC-REG-013
│       └── test_stress_dsr_rate.py     ← TC-REG-014
│
├── regulatory_reports/
├── docker-compose.yml
├── docker-compose.prod.yml
├── Makefile
└── .env.example
```

---

## 4. 개발 환경 구성

### 4.1 환경 분리 전략

```
[로컬 개발 환경]
  - docker-compose.yml 기반 단일 명령 실행
  - 합성 데이터 사용 (실제 개인정보 금지)
  - Mock CB API 서버 포함
  - 기능: make up → 전체 스택 실행

[스테이징 환경]
  - 운영 동일 아키텍처 (1/4 스케일)
  - 마스킹된 실데이터 또는 고품질 합성 데이터
  - 외부 연동: CB API Sandbox 환경 연결
  - 성능 테스트, 통합 테스트 실행 환경

[운영 환경 (DR 포함)]
  - 실제 CB API 연결
  - HSM 기반 암호화 키 관리
  - 감독당국 보고 가능 수준 감사 로그
```

### 4.2 로컬 개발 즉시 실행 가이드

```makefile
# Makefile 완성 형태 (개발자 온보딩 첫날 사용)

setup:        ## 최초 환경 설정 (클론 후 한 번만 실행)
	cp .env.example .env
	docker compose up -d postgres redis kafka
	pip install -r backend/requirements.txt
	cd backend && alembic upgrade head
	cd ml_pipeline && python data/synthetic_data.py

dev:          ## 개발 서버 실행
	docker compose up -d postgres redis kafka
	cd backend && uvicorn app.main:app --reload --port 8000

train:        ## 전체 모델 학습 (합성 데이터 기반)
	cd ml_pipeline && python training/train_application_salaried.py
	cd ml_pipeline && python training/train_application_business.py
	cd ml_pipeline && python training/train_application_pensioner.py
	cd ml_pipeline && python training/train_behavioral.py
	cd ml_pipeline && python training/train_collection.py

test:         ## 전체 테스트 (PR 전 필수 실행)
	pytest tests/ -v --cov=app --cov-fail-under=80

test-reg:     ## 규제 준수 테스트만 (컴플라이언스 팀 전용)
	pytest tests/regulatory/ -v -s --tb=short

lint:         ## 코드 품질 검사
	ruff check backend/app/ && mypy backend/app/ --ignore-missing-imports
	bandit -r backend/app/ -ll
```

### 4.3 코드 리뷰 프로세스

```
[PR 체크리스트 — 모든 PR에 의무 적용]

기능 관련:
□ 요건 정의서 요건 ID와 구현 코드 연결 주석 포함
  예) # FR-REG-001: DSR 40% 초과 시 승인 불가 [은행업감독규정 §79]
□ 정상 케이스 + 경계값 + 비정상 입력 모두 테스트
□ 규제 관련 코드는 반드시 주석에 법령 조항 기재

보안 관련:
□ 개인정보 로그 출력 없음 확인 (주민번호, 계좌번호)
□ SQL 쿼리 파라미터 바인딩 (f-string 직접 삽입 금지)
□ 외부 입력값 검증 전 비즈니스 로직 실행 금지

리뷰어 요건:
□ 최소 2인 승인 필수
□ 규제 관련 코드: 컴플라이언스 담당 은행 측 검토 필수
□ ML 모델 코드: ML 엔지니어 리드 승인 필수
```

---

## 5. 단계별 개발 계획

### Phase 0: 착수 및 기반 설정 (4주, 2026-04-01~04-30)

**목표**: 개발 시작을 위한 모든 전제 조건 완료

#### 주차별 작업

**Week 1-2: 요건 확정 및 환경 구성**

| 작업 | 담당 | 산출물 | 완료 기준 |
|------|------|--------|---------|
| 요건 정의서 전체 리뷰 및 질의 해소 | 전 팀원 + 은행 측 | 질의응답 목록 | 미해결 질의 0건 |
| CB API 계약 확인 및 Sandbox 접근 | 은행 IT + 백엔드 리드 | Sandbox 연결 성공 | API 호출 성공 |
| CBS 인터페이스 명세 수령 | 은행 IT + 백엔드 리드 | IF 명세서 | 명세 완료 |
| 개발 환경 구성 (Docker Compose) | DevOps | docker-compose.yml | make up 성공 |
| Git Repository 초기화 + 브랜치 전략 | 아키텍처 리드 | Repository | 브랜치 규칙 문서 |
| CI/CD 파이프라인 초안 | DevOps | GitHub Actions | PR 시 테스트 자동 실행 |

**Week 3-4: DB 스키마 + 마이그레이션 + 코어 설정**

| 작업 | 담당 | 산출물 | 완료 기준 |
|------|------|--------|---------|
| DB ERD 설계 확정 (15개 테이블) | DB 엔지니어 | ERD 문서 + 은행 검토 | 은행 IT 서명 |
| Alembic 마이그레이션 스크립트 작성 | DB 엔지니어 | migration 파일 | alembic upgrade head 성공 |
| SQLAlchemy ORM 모델 전체 작성 | 백엔드 | schemas/ 전체 | 단위 테스트 통과 |
| config.py 규제 파라미터 완성 | 백엔드 리드 | config.py | 모든 규제값 포함 확인 |
| 합성 데이터 생성기 유형별 분리 | ML 엔지니어 | synthetic_data.py | 5종 데이터 생성 성공 |

**Phase 0 완료 기준 (품질 게이트)**:
- [ ] DB 마이그레이션 성공
- [ ] CI/CD 파이프라인에서 빈 테스트 실행 성공
- [ ] CB API Sandbox 연동 성공
- [ ] 은행 IT 담당자 환경 접속 확인

---

### Phase 1: ML 파이프라인 (8주, 2026-05-01~06-26)

**목표**: 3종 × 3유형 = 5개 Scorecard 학습 및 검증 완료

#### Sprint 1-2 (Week 1-4): Application Scorecard

**직장인 버전 (train_application_salaried.py)**

| 작업 | 세부 내용 | 완료 기준 |
|------|---------|---------|
| 피처 그룹 확정 | CB 피처 + EQ Grade Score + OSI Score + 재무비율 | 피처 목록 확정 |
| WOE/IV 계산 | 10분위 구간화, EQ Grade Score IV 계산 | IV 보고서 생성 |
| LightGBM 학습 | 5-Fold CV, scale_pos_weight 적용 | CV AUC ≥ 0.70 |
| OOT 검증 | 시간 기반 분리 (2023.07+) | OOT Gini ≥ 0.30 |
| 공정성 검사 | 연령대별 Gini 차이 | 차이 ≤ 0.15 |
| SHAP 한국어 매핑 | SHAP 변수명 → 한국어 문장 템플릿 | 전 피처 매핑 완료 |
| 모델카드 생성 | JSON 형식, 금감원 9개 항목 | 필수 항목 100% |

**개인사업자 버전 (train_application_business.py)**

| 작업 | 세부 내용 | 완료 기준 |
|------|---------|---------|
| 사업자 전용 피처 추가 | IRG Score, 매출증가율 구간, 세금 성실도 Score | 피처 목록 확정 |
| WOE/IV 계산 | 사업자 전용 변수 포함 | IV 보고서 생성 |
| LightGBM 학습 | 업종 리스크 고려 stratified split | OOT Gini ≥ 0.28 |
| IRG별 부도율 단조성 검증 | IRG-L < IRG-M < IRG-H < IRG-VH | 단조성 100% |

#### Sprint 3 (Week 5-6): Behavioral + Collection Scorecard

**Behavioral Scorecard (train_behavioral.py)**

| 작업 | 세부 내용 | 완료 기준 |
|------|---------|---------|
| 목표변수 재정의 | 30일 이상 연체 발생 (6개월 이내) | 정의 문서화 |
| 행동 변수 추가 | 상환 패턴, 잔액 비율, 미납 횟수 | 피처 추가 완료 |
| XGBoost 학습 | Application과 동일 검증 프레임워크 | OOT Gini ≥ 0.25 |

**Collection Scorecard (train_collection.py)**

| 작업 | 세부 내용 | 완료 기준 |
|------|---------|---------|
| 목표변수 | 90일 내 전액 상환(회수 성공) | 정의 문서화 |
| 추심 변수 추가 | 연체 기간, 연체 금액, 접촉 이력 | 피처 추가 완료 |
| Random Forest 학습 | 회수 가능성 예측 | OOT Gini ≥ 0.20 |

#### Sprint 4 (Week 7-8): 검증 체계 완성

| 작업 | 담당 | 산출물 |
|------|------|--------|
| 4개 역할 검증 테스트 완성 | QA + ML | validation/roles/ 전체 |
| SHAP 한국어 변환 품질 검증 | ML + 은행 현업 | 변환 품질 확인서 |
| 모델 성과 비교 대시보드 | ML + 백엔드 | Shadow 비교 화면 |

**Phase 1 완료 기준 (품질 게이트)**:

```
□ Application Scorecard (직장인): OOT Gini ≥ 0.30
□ Application Scorecard (사업자): OOT Gini ≥ 0.28
□ Application Scorecard (연금): OOT Gini ≥ 0.25
□ Behavioral Scorecard: OOT Gini ≥ 0.25
□ Collection Scorecard: OOT Gini ≥ 0.20
□ 전체 모델 PSI < 0.20
□ 전체 모델 공정성 (연령대 Gini 차이 ≤ 0.15)
□ 모델카드 JSON 5개 완성 (금감원 9개 항목 포함)
□ 4개 역할 검증 테스트 전건 통과
```

---

### Phase 2: 백엔드 코어 엔진 (8주, 2026-06-29~08-21)

**목표**: 신용평가 핵심 비즈니스 로직 구현 완료

#### Sprint 5 (Week 1-2): 규제 하드컷 엔진 + 유형 판별

**hard_cut_engine.py** — 최우선 구현

```
구현 순서 (중요도 순):
1. DSR 스트레스 하드컷 (FR-REG-001) — 가장 빈번히 발동
2. 최고금리 상한 (FR-REG-010) — 매 건 적용
3. CB 동의 선행 강제 (FR-REG-005) — 모든 건 선행
4. 미성년자 자동 거절 (FR-REG-003)
5. LTV 하드컷 (FR-REG-002)
6. 다주택자 LTV 추가 하향 (FR-REG-006)
7. 세금 체납 거절 (FR-REG-004)
8. 개인사업자 사업 기간 (FR-REG-007)
9. 매출 급감 경보 (FR-IRG-002)
```

**구현 원칙**: 하드컷은 함수 단위로 격리, 각각 독립 테스트 가능하게 설계

```python
# hard_cut_engine.py 구조 예시
class HardCutEngine:
    """
    규제 하드컷 엔진 — 모든 하드컷은 이 클래스에서만 처리
    각 하드컷은 독립 메서드로 구현하여 단위 테스트 가능
    """

    def run_all(self, request: ScoringRequest) -> HardCutResult:
        """
        하드컷 실행 순서는 규제 우선순위에 따라 고정
        순서 변경 시 이 메서드만 수정 (분산 방지)
        """
        # FR-REG-005: CB 동의 최우선 확인
        if not self._check_cb_consent(request):
            return HardCutResult.reject("CB_CONSENT_MISSING")

        # FR-REG-003: 미성년자
        if self._check_minor(request):
            return HardCutResult.reject("UNDERAGE")

        # FR-REG-004: 세금 체납 (개인사업자)
        if request.applicant_type == "individual_business":
            if self._check_tax_delinquency(request):
                return HardCutResult.reject("TAX_DELINQUENT")

        # FR-REG-001: 스트레스 DSR
        dsr_result = self._check_stress_dsr(request)
        if dsr_result.exceeded:
            if dsr_result.reduced_amount > 0:
                return HardCutResult.reduce_limit(dsr_result.reduced_amount)
            return HardCutResult.reject("DSR_EXCEED")

        # FR-REG-002: LTV (주담대)
        if request.product_type == "mortgage":
            ltv_result = self._check_ltv(request)
            if ltv_result.exceeded:
                return HardCutResult.reject("LTV_EXCEED")

        return HardCutResult.pass_all()
```

**stress_dsr.py** — 스트레스 DSR 전용 모듈

```python
# FR-REG-001, DSR 계산 공식 구현
class StressDSRCalculator:
    """
    스트레스 DSR 계산기
    [은행업감독규정 §79] + [금감원 스트레스 DSR 행정지도]
    """

    STRESS_RATE = {
        "metropolitan": {
            "phase1": 0.0038,   # 2023.07 시행
            "phase2": 0.0075,   # 2024.02 시행 (현행)
        },
        "non_metropolitan": {
            "phase1": 0.0075,
            "phase2": 0.0150,   # 현행
        }
    }
    CURRENT_PHASE = "phase2"

    def calc_stress_rate(self, base_rate: float, rate_type: str,
                         region: str) -> float:
        """
        심사금리 = max(신청금리, 신청금리 + 스트레스 가산금리)
        고정금리는 스트레스 미적용
        """
        if rate_type == "fixed":
            return base_rate
        stress = self.STRESS_RATE[region][self.CURRENT_PHASE]
        return base_rate + stress

    def calc_monthly_payment(self, principal: float, annual_rate: float,
                              months: int) -> float:
        """원리금균등상환 월 납입액"""
        r = annual_rate / 12
        if r == 0:
            return principal / months
        return principal * r * (1 + r)**months / ((1 + r)**months - 1)

    def calc_stress_dsr(self, request: ScoringRequest) -> StressDSRResult:
        stress_rate = self.calc_stress_rate(
            request.applied_rate,
            request.rate_type,
            request.stress_dsr_region,
        )
        new_monthly = self.calc_monthly_payment(
            request.requested_amount, stress_rate, request.term_months
        )
        total_monthly = request.existing_monthly_payment + new_monthly
        dsr = total_monthly / request.monthly_income * 100

        return StressDSRResult(
            dsr=dsr,
            exceeded=dsr > 40.0,
            stress_rate_applied=stress_rate,
            reduced_amount=self._calc_max_amount(request, stress_rate)
            if dsr > 40.0 else 0,
        )
```

#### Sprint 6 (Week 3-4): 신청자 유형 판별 + 피처 엔지니어링

**applicant_classifier.py**

```
[유형 판별 로직 구현]
Input: 사업자번호(optional), 4대보험 조회 결과, 연금 조회 결과
Output: ApplicantType (Track-S/B/P/F)

[구현 세부]
1. 사업자번호 → 국세청 API 사업자 상태 조회
   유효 → Track-B (개인사업자)
2. 고용보험 또는 4대보험 가입 확인
   확인 → Track-S (직장인)
3. 국민/공무원연금 수급 확인
   확인 → Track-P (연금소득자)
4. 미확인 → Track-F 또는 소액론 한정 처리

[캐싱 전략]
사업자 상태 조회 결과: Redis에 1시간 캐시
(같은 날 재신청 시 재조회 불필요)
```

**feature_engineering.py** — 유형별 분기 설계

```
[공통 CB 피처] (모든 유형)
  cb_score, delinquency_*, inquiry_count_*, worst_delinquency_status
  open_loan_count, credit_card_count

[Track-S 추가 피처]
  eq_grade_score          : EQ Grade → 점수 변환 (EQ-S=100, E=15)
  osi_score               : 직종 안정성 지수
  employment_stability    : 근속×계약유형×EQ 복합 지수
  income_reliability      : 소득 검증 신뢰도

[Track-B 추가 피처]
  business_age_band       : 12M미만/12~24/24~60/60+ 구간
  revenue_growth_band     : <-30%/-30~0/0~20%/20%+ 구간
  irg_score               : IRG Grade → 점수 변환 (L=100, VH=15)
  tax_compliance_score    : 세금 성실도 복합 지수
  income_recognition_adj  : 인정소득 × 신뢰도 계수

[Track-P 추가 피처]
  pension_type_score      : 연금 유형 안정성 (공무원>국민>기타)
  pension_remaining_years : 수령 잔여 기간 추정
```

#### Sprint 7 (Week 5-6): 한도/금리 산출 + EQ/IRG 서비스

**limit_calculator.py** — 유형별 한도 산출 통합

```python
class LimitCalculator:
    """
    [FR-LMT-001, FR-LMT-002, FR-LMT-003]
    신청자 유형별 한도 산출 — 세 값의 최솟값이 최종 한도
    """

    def calculate(self, request: ScoringRequest,
                  applicant: Applicant) -> LimitResult:
        if applicant.applicant_type == "individual_salaried":
            income_based = self._calc_salaried_income_limit(applicant)
        elif applicant.applicant_type == "individual_business":
            income_based = self._calc_business_income_limit(applicant)
        elif applicant.applicant_type == "individual_pensioner":
            income_based = self._calc_pension_income_limit(applicant)

        dsr_based = self._calc_dsr_limit(request, applicant)
        product_max = self._get_product_max(request.product_type, applicant)

        final_limit = min(income_based, dsr_based, product_max)
        return LimitResult(
            income_based_limit=income_based,
            dsr_based_limit=dsr_based,
            product_max_limit=product_max,
            final_limit=final_limit,
            binding_constraint=self._identify_binding(
                income_based, dsr_based, product_max
            ),
        )

    def _calc_salaried_income_limit(self, applicant: Applicant) -> float:
        # FR-LMT-001: 소득 인정액 × EQ 배수
        recognized_income = (applicant.income_annual
                             * applicant.income_recognition_reliability)
        eq_multiplier = EQ_MULTIPLIER_MAP[applicant.employer_eq_grade]
        return recognized_income * eq_multiplier
```

**eq_grade_service.py** — EQ 등급 조회 및 캐싱

```
[조회 순서 + 캐싱 전략]
1. Redis 캐시 확인 (key: eq_grade:{사업자번호}, TTL: 6개월)
   → 히트: 캐시 반환
2. 내부 EQ 등급 DB 조회 (갱신일 6개월 이내)
   → 유효: DB 반환, Redis 업데이트
3. 외부 기업신용정보 API (NICE/KED) 조회
   → 성공: DB 저장, Redis 업데이트, 반환
4. DART 상장 여부 확인 (KOSPI/KOSDAQ)
5. 알리오 공공기관 여부 확인
6. 실패: EQ-D 기본값 + 수동 조정 플래그 설정

[에러 처리]
  외부 API 타임아웃(2초) → EQ-D 기본 + 경보 발령
  조회 결과가 6개월 이상 구식 → 자동 재조회 요청 큐 등록
```

#### Sprint 8 (Week 7-8): 설명 엔진 + 감사 로그

**explanation_engine.py** — SHAP 한국어 변환

```python
# 변수별 한국어 설명 템플릿 (예시)
EXPLANATION_TEMPLATES = {
    "cb_score": {
        "negative": "신용점수({value}점)가 평균({mean}점)보다 낮아 신용점수에 {impact:+}점 영향",
        "positive": "신용점수({value}점)가 우수하여 신용점수에 {impact:+}점 기여",
    },
    "inquiry_count_3m": {
        "negative": "최근 3개월 신용조회 횟수({value}회)가 평균({mean}회)보다 많아 {impact:+}점 영향",
    },
    "dsr_ratio": {
        "negative": "부채상환비율({value:.1f}%)이 높아 신용점수에 {impact:+}점 영향",
    },
    "eq_grade_score": {
        "negative": "고용주 신용도({grade})가 낮아 승인 한도에 영향을 미쳤습니다",
        "positive": "고용주 신용도({grade})가 우수하여 한도에 긍정적으로 반영되었습니다",
    },
    "revenue_growth_rate": {
        "negative": "전년 대비 매출이 {value:.1f}% 감소하여 신용점수에 {impact:+}점 영향",
    },
    # ... 전체 피처 커버
}

class ExplanationEngine:
    def generate_rejection_reasons(
        self, shap_values: np.ndarray,
        feature_names: list[str],
        feature_values: dict,
        reference_means: dict,
        hard_cut_reason: str | None = None,
    ) -> list[str]:
        """
        [FR-EXP-001] 거절 사유 3개 생성
        하드컷 사유가 있으면 1순위, 나머지는 SHAP 기반
        """
        reasons = []

        # 1순위: 하드컷 사유
        if hard_cut_reason:
            reasons.append(self._hard_cut_to_korean(hard_cut_reason))

        # 나머지: SHAP 상위 기여 변수
        top_negative = self._get_top_negative_shap(
            shap_values, feature_names, n=3 - len(reasons)
        )
        for feat, shap_val in top_negative:
            template = EXPLANATION_TEMPLATES.get(feat, {})
            if shap_val < 0:  # 부도 가능성을 높이는 방향
                tmpl = template.get("negative", f"{feat} 항목이 영향을 미쳤습니다")
            else:
                tmpl = template.get("positive", "")
            reasons.append(tmpl.format(
                value=feature_values.get(feat, ""),
                mean=reference_means.get(feat, ""),
                impact=int(abs(shap_val) * 100),
                grade=feature_values.get("eq_grade", ""),
            ))

        return reasons[:3]
```

**audit_logger.py** — Kafka 기반 감사 로그

```python
class AuditLogger:
    """
    [FR-CNS-001, 신용정보법 §20의2]
    모든 신용평가 이력을 Kafka에 발행 → Consumer가 PostgreSQL에 영속 저장
    Fire-and-forget 금지 — Kafka 발행 실패 시 평가 응답도 실패 처리
    """

    def __init__(self, producer: AIOKafkaProducer):
        self.producer = producer
        self.topic = "audit-log"

    async def log_scoring_event(self, request: ScoringRequest,
                                result: ScoringResult) -> None:
        payload = AuditLogPayload(
            event_type="CREDIT_SCORING",
            timestamp_ms=int(time.time() * 1000),
            application_id=str(result.application_id),
            user_id=request.operator_id,
            user_role=request.operator_role,
            applicant_type=result.applicant_type,
            credit_score=result.credit_score,
            decision=result.decision,
            hard_cut_triggered=result.hard_cut_triggered,
            dsr_ratio=result.dsr_ratio,
            eq_grade_applied=result.eq_grade_applied,
            irg_applied=result.irg_applied,
        )
        # Kafka 발행 실패 시 예외 발생 → 평가 응답도 실패
        # (감사 로그 없는 평가 결과는 규제 위반)
        await self.producer.send_and_wait(
            self.topic,
            key=str(result.application_id).encode(),
            value=payload.model_dump_json().encode(),
        )
```

**Phase 2 완료 기준 (품질 게이트)**:

```
□ 규제 준수 테스트 TC-REG-001~014 전건 통과
□ 유형별 한도 산출 테스트 TC-TYPE-001~007 전건 통과
□ 단위 테스트 커버리지 ≥ 80% (hard_cut, stress_dsr, limit_calculator)
□ P95 응답 시간 ≤ 500ms (모델 로딩 포함, 로컬 환경)
□ SHAP 한국어 변환 전 피처 커버리지 100%
□ 감사 로그 Kafka 발행 성공률 100% (1,000건 테스트)
```

---

### Phase 3: FastAPI REST API (6주, 2026-08-24~10-02)

**목표**: 전체 API 엔드포인트 구현, RBAC, 외부 연동 완성

#### Sprint 9 (Week 1-2): 핵심 API + RBAC

**scoring.py** — 평가 API 구현

```python
# POST /api/v1/score
@router.post("/score", response_model=ScoringResponse)
async def score_application(
    request: ScoringRequest,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(require_role(["teller", "reviewer"])),
    scoring_engine: ScoringEngine = Depends(get_scoring_engine),
    audit_logger: AuditLogger = Depends(get_audit_logger),
):
    """
    [FR-SCR-001] 실시간 신용평가 — 500ms 이내 응답 목표
    실행 순서:
    1. CB 동의 확인 (FR-REG-005)
    2. 유형 판별 (FR-TYPE-001)
    3. 피처 엔지니어링
    4. 하드컷 사전 검사 (FR-REG 전체)
    5. 모델 추론 + SHAP
    6. 한도/금리 산출
    7. 하드컷 후처리 (최고금리 상한 등)
    8. 감사 로그 발행 (Kafka)
    9. 응답 반환
    """
    result = await scoring_engine.evaluate(request, current_user)
    await audit_logger.log_scoring_event(request, result)
    return ScoringResponse.from_result(result)
```

**rbac.py** — 역할 기반 접근 제어

```python
# [NFR-SEC-005] RBAC 구현
ROLE_PERMISSIONS: dict[str, set[str]] = {
    "teller": {          # 영업점 직원
        "score:create",
        "application:read_own",
    },
    "reviewer": {        # 심사관
        "score:create",
        "application:read_all",
        "application:review",
    },
    "risk_manager": {    # 리스크팀
        "application:read_all",
        "monitoring:read",
        "report:generate",
    },
    "auditor": {         # 내부감사팀
        "application:read_all",
        "audit_log:read",
        "monitoring:read",
    },
    "it_admin": {        # IT 관리자
        "model:upload",
        "audit_log:read",
        "system:admin",
    },
    "head_of_lending": { # 여신총괄
        "application:read_all",
        "monitoring:read",
        "params:update",   # 규제 파라미터 변경
        "report:generate",
    },
}

def require_role(required_roles: list[str]):
    def dependency(user: User = Depends(get_current_user)):
        if user.role not in required_roles:
            raise HTTPException(
                status_code=403,
                detail=f"권한 없음: {user.role}는 이 작업을 수행할 수 없습니다"
            )
        return user
    return dependency
```

#### Sprint 10 (Week 3-4): 외부 연동 + 관리자 API

**cb_client.py** — CB API 연동 (재시도 + 장애 처리)

```python
class CBClient:
    """
    [FR-CNS-001] CB API 클라이언트
    3회 재시도 → 실패 시 수동심사 이관
    """

    MAX_RETRIES = 3
    RETRY_INTERVAL = 1.0  # 초

    async def query(self, resident_hash: str,
                    consent_id: str) -> CBQueryResult:
        last_error = None
        for attempt in range(self.MAX_RETRIES):
            try:
                async with asyncio.timeout(2.0):  # 2초 타임아웃
                    result = await self._do_query(resident_hash, consent_id)
                    return result
            except (asyncio.TimeoutError, CBAPIException) as e:
                last_error = e
                if attempt < self.MAX_RETRIES - 1:
                    await asyncio.sleep(self.RETRY_INTERVAL)

        # 3회 실패 → 수동심사 이관 신호
        raise CBQueryFailedException(
            "CB 조회 3회 실패 → 수동 심사 이관 필요",
            cause=last_error
        )
```

**admin.py** — 파라미터 관리 API

```python
# PUT /api/v1/admin/params
# [FR-ADM-001] 규제 파라미터 배포 없이 실시간 변경
@router.put("/params/{param_key}")
async def update_param(
    param_key: str,
    body: ParamUpdateRequest,
    db: AsyncSession = Depends(get_db),
    user: User = Depends(require_role(["head_of_lending", "it_admin"])),
    param_service: ParamService = Depends(),
):
    old_value = await param_service.get(param_key)
    await param_service.update(param_key, body.value)

    # 감사 로그: 파라미터 변경 이력
    await audit_logger.log_param_change(
        param_key=param_key,
        old_value=old_value,
        new_value=body.value,
        changed_by=user.id,
        reason=body.reason,
    )

    # Redis 캐시 무효화 → 다음 요청부터 즉시 반영
    await cache.delete(f"param:{param_key}")

    return {"status": "applied", "effective_immediately": True}
```

#### Sprint 11 (Week 5-6): 모니터링 API + Shadow 대시보드

**monitoring.py** — PSI/RAROC 모니터링 엔드포인트

```python
# GET /api/v1/monitoring/psi?period=monthly
# [FR-MON-002] PSI 3종 조회
@router.get("/psi")
async def get_psi_report(
    period: str = "monthly",
    user: User = Depends(require_role(["risk_manager", "head_of_lending"])),
    psi_service: PSICalculator = Depends(),
):
    return {
        "score_psi": await psi_service.calc_score_psi(period),
        "feature_psi": await psi_service.calc_feature_psi(period),
        "target_psi": await psi_service.calc_target_psi(period),
        "status": psi_service.determine_status(),
        "alert_triggered": psi_service.check_alerts(),
    }
```

**Phase 3 완료 기준 (품질 게이트)**:

```
□ 전체 API 엔드포인트 9개 구현 완료
□ RBAC 침해 테스트 TC-SEC-003 통과 (각 역할별 권한 검증)
□ CB API 연동 성공 (Sandbox 환경)
□ 관리자 파라미터 변경 후 즉시 반영 확인
□ Shadow 대시보드 챌린저 결과 비공개 확인
□ 통합 테스트 전건 통과
```

---

### Phase 4: 보안 + 성능 최적화 (4주, 2026-10-05~10-30)

**목표**: 보안 취약점 0건, P95 ≤ 500ms @ 200 TPS 달성

#### Sprint 12 (Week 1-2): 보안 구현 완성

**crypto.py** — 암호화 유틸

```python
import hmac, hashlib, os
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

class CryptoService:
    """
    [NFR-SEC-002, NFR-SEC-003] 암호화 서비스
    주민번호: HMAC-SHA256 (레인보우 테이블 방지)
    계좌번호: AES-256-GCM (복호화 필요 시 사용)
    """

    def __init__(self):
        # 환경변수에서 로드 (절대 코드에 하드코딩 금지)
        self._hmac_key = os.environ["KCS_HMAC_SECRET_KEY"].encode()
        self._aes_key = bytes.fromhex(os.environ["KCS_AES_KEY_HEX"])
        assert len(self._aes_key) == 32, "AES 키는 256비트(32바이트)여야 함"

    def hash_resident_number(self, resident_number: str) -> str:
        """
        HMAC-SHA256으로 주민번호 해시
        동일한 주민번호 → 항상 동일한 해시 (중복 검사 가능)
        """
        h = hmac.new(self._hmac_key, resident_number.encode(), hashlib.sha256)
        return h.hexdigest()  # 64자 16진수

    def encrypt_account_number(self, account_number: str) -> str:
        """AES-256-GCM 암호화 (복호화 가능, 화면 표시용)"""
        aesgcm = AESGCM(self._aes_key)
        nonce = os.urandom(12)
        ct = aesgcm.encrypt(nonce, account_number.encode(), None)
        return (nonce + ct).hex()

    def decrypt_account_number(self, encrypted_hex: str) -> str:
        data = bytes.fromhex(encrypted_hex)
        nonce, ct = data[:12], data[12:]
        aesgcm = AESGCM(self._aes_key)
        return aesgcm.decrypt(nonce, ct, None).decode()
```

**보안 점검 항목** (제3자 보안 전문기관 수행):

```
[자동화 스캔]
□ Bandit (Python 보안 정적 분석) — High/Critical 0건
□ OWASP Dependency Check (취약 라이브러리) — Critical 0건
□ Trivy (Docker 이미지 취약점) — High 이상 0건

[수동 침투 테스트]
□ SQL Injection (모든 입력 필드)
□ JWT 위변조 (알고리즘 변경, 서명 제거)
□ RBAC 침해 (역할별 우회 시도)
□ Rate Limiting 우회
□ 개인정보 노출 (로그, 에러 메시지, 응답 헤더)
□ IDOR (타 고객 데이터 접근)
```

#### Sprint 13 (Week 3-4): 성능 최적화

**성능 목표 달성 전략**:

```
[병목 분석 기준점]
현재 예상 응답 시간 분포:
  CB API 조회:          250ms (외부 의존, 최적화 불가)
  EQ Grade 조회:         50ms (Redis 캐시로 5ms 가능)
  모델 추론:             50ms (LightGBM 빠름)
  SHAP 계산:            80ms → 최적화 필요
  DB 저장 (Kafka):      10ms
  기타:                  60ms
  합계:                 500ms (목표 경계)

[최적화 방안]
① SHAP 최적화 (80ms → 30ms):
   - TreeExplainer 재사용 (요청마다 생성 금지, 앱 시작 시 1회 초기화)
   - Top-5 피처만 계산 (전체 계산 불필요)
   - shap.Explainer(..., approximate=True) 사용 검토

② EQ Grade 캐싱 (50ms → 5ms):
   - Redis 캐시 TTL 6개월
   - 캐시 미스 시 비동기 백그라운드 갱신

③ DB 쿼리 최적화:
   - 감사 로그 저장을 Kafka 비동기로 (응답 경로에서 제거)
   - 읽기 전용 쿼리는 Read Replica 사용

④ 커넥션 풀 튜닝:
   - asyncpg 풀: min=5, max=20
   - aioredis 풀: max=10

[성능 테스트 절차]
  k6 스크립트로 200 TPS 30분 부하 테스트
  → Grafana 대시보드로 P50/P95/P99 실시간 확인
  → P95 > 400ms 시 추가 최적화 진행 (목표보다 20% 여유)
```

**Phase 4 완료 기준 (품질 게이트)**:

```
□ 보안 취약점 테스트: Critical/High 0건 (제3자 기관 확인서)
□ 성능 테스트: P95 ≤ 400ms @ 200 TPS (목표 대비 20% 여유)
□ 배치 처리 (행동평점): 100만 건 5시간 이내
□ 개인정보 평문 노출 0건 (로그, 응답, DB 전수 확인)
```

---

### Phase 5: 통합 테스트 + UAT (6주, 2026-11-02~12-11)

**목표**: 전체 시스템 E2E 검증, 현업 합격

#### Sprint 14-15 (Week 1-4): 통합 테스트 실행

**규제 준수 테스트 (은행 컴플라이언스팀 주관)**:

```
[실행 환경]
  스테이징 환경 (운영 동일 사양)
  CB Sandbox API 연결
  실제와 동일한 파라미터 설정

[테스트 자동화 스크립트]
  pytest tests/regulatory/ -v -s --tb=long \
    --html=reports/regulatory_test_$(date +%Y%m%d).html \
    --json=reports/regulatory_test_$(date +%Y%m%d).json

  # 1건이라도 실패 시 즉시 중단 (--exitfirst)
  pytest tests/regulatory/ --exitfirst

[합격 기준]
  TC-REG-001~014: 전건 통과
  TC-TYPE-001~007: 전건 통과
  합격률 100% 미만 시 개발팀 즉시 통보, Phase 5 진행 중단
```

**감사 로그 완전성 테스트**:

```python
# test_audit_log_integrity.py
def test_audit_log_completeness(scoring_api, audit_db):
    """10,000건 평가 후 감사 로그 누락 0건 검증"""
    application_ids = []
    for _ in range(10_000):
        resp = scoring_api.post("/api/v1/score", json=sample_request())
        application_ids.append(resp.json()["application_id"])

    # 감사 DB에서 모든 ID 존재 확인
    missing = audit_db.find_missing(application_ids)
    assert len(missing) == 0, f"감사 로그 누락: {len(missing)}건 — {missing[:5]}"
```

#### Sprint 16 (Week 5-6): UAT (현업 주관)

**UAT 진행 방식**:

```
[준비 단계]
  - 영업점 직원 10명, 심사관 5명 선발 (실제 업무 담당자)
  - UAT 시나리오 10개를 현업이 직접 작성 (SI 업체 작성 불인정)
  - UAT 환경: 스테이징 (실제 영업점 PC에서 접속)

[실행 단계]
  - 현업이 직접 시나리오 수행 (SI 업체 보조만 허용)
  - 각 시나리오별 통과/실패 기록
  - 실패 시 스크린샷 + 재현 절차 문서화

[합격 기준]
  - 10개 시나리오 중 9.5개 이상 통과 (합격률 95%)
  - UAT-001~UAT-010 항목 중 규제 관련(UAT-003~007)은 100% 필수
  - 현업 팀장 서명으로 최종 합격 확인

[UAT 결과 처리]
  합격: Phase 6 (운영 이관) 진행
  불합격: 실패 항목 수정 후 UAT 재실행 (최대 2회)
  2회 연속 불합격: 계약 위약금 조항 적용
```

**Phase 5 완료 기준 (품질 게이트)**:

```
□ 규제 준수 테스트 TC-REG-001~014 전건 통과 (컴플라이언스팀 서명)
□ 통합 테스트 전건 통과
□ 감사 로그 완전성: 10,000건 중 누락 0건
□ UAT 합격률 ≥ 95% (현업 팀장 서명)
□ 보고서 자동 생성 4종 검증 완료
```

---

### Phase 6: 운영 이관 + 안정화 (4주, 2026-12-14~2027-01-09)

**목표**: 운영 환경 배포, KT 완료, 안정화 확인

#### Week 1-2: 운영 환경 구성 + KT

**운영 환경 체크리스트**:

```
인프라:
□ 운영 서버 2중화 구성 확인
□ DR 사이트 페일오버 테스트 성공
□ HSM 기반 암호화 키 관리 구성
□ Kafka 3 Broker 클러스터 정상 동작
□ Prometheus + Grafana 대시보드 정상 표시
□ Elasticsearch 감사 로그 수집 확인

보안:
□ 운영 TLS 인증서 설치 (유효기간 1년 이상)
□ JWT RS256 키 페어 운영 적용
□ 환경변수 보안 (HMAC_SECRET, AES_KEY 운영 값)
□ 방화벽 규칙 확인 (CB API 전용 출구 IP)
□ MFA 관리자 계정 생성

데이터:
□ 초기 EQ Grade DB 로딩 (주요 기업 1만개+)
□ IRG 매핑 테이블 로딩 (KSIC 전체)
□ 규제 파라미터 운영값 설정 (기준금리, DSR 한도 등)
□ ML 모델 아티팩트 배포 완료
```

**KT (Knowledge Transfer) 체크리스트** — 은행 IT팀 단독 수행:

```
[KT 합격 기준: SI 업체 없이 아래 항목 수행 성공]

□ 시스템 시작/종료 (docker compose 명령)
□ 단일 컴포넌트 재시작 (API 서버만 재시작)
□ 모델 파일 교체 (관리자 화면으로 직접)
□ 규제 파라미터 변경 (기준금리 변경 후 즉시 반영 확인)
□ 감사 로그 조회 (특정 고객 ID로 전체 이력 검색)
□ Grafana 대시보드 PSI 지표 확인
□ P1 장애 시뮬레이션 → 복구 (API 서버 강제 종료 후 자동 재시작)
□ DB 백업 수동 실행 및 복구 테스트
□ Kafka Consumer 지연 발생 시 확인 및 재시작

KT 불합격 항목 존재 시: 추가 KT 세션 (최대 3회)
3회 후에도 불합격: 운영 이관 대금(20%) 지급 보류
```

#### Week 3-4: 소프트 런치 + 모니터링

```
[소프트 런치 전략]
  1단계 (Day 1-7):   영업점 1개 점포만 운영
  2단계 (Day 8-14):  10개 점포 확대
  3단계 (Day 15-21): 전 점포 오픈 (비대면 채널 포함)

[일별 점검 항목]
□ 승인율 전일 대비 ±5%p 이내 (±10%p 초과 시 즉시 보고)
□ 평균 응답 시간 P95 추이
□ 거절 사유 분포 이상 여부
□ Kafka Consumer Lag 0 유지
□ 감사 로그 실시간 수집 확인
```

---

### Phase 7: 3개월 안정화 (2027-01-10~04-10)

**목표**: 안정화 기간 동안 P1 장애 0건 유지, SLA 99.9% 달성

```
[안정화 기간 활동]

월별 정기 점검:
  □ PSI 3종 보고서 자동 생성 및 리스크팀 배포
  □ RAROC 포트폴리오 분석
  □ 등급별 부도율 추이 모니터링
  □ EQ Grade DB 갱신 (분기 1회)
  □ IRG 테이블 업데이트 검토

안정화 기간 완료 기준:
  □ 3개월 연속 P1 장애 0건
  □ SLA 99.9% 달성 (3개월 합산)
  □ 규제 준수 테스트 월 1회 자동 실행 정상 통과
  □ 잔여 하자 Minor 이하만 존재
```

---

## 6. 컴포넌트별 상세 구현 계획

### 6.1 scoring_engine.py — 평가 오케스트레이터

```
[역할] 전체 평가 흐름 조율. 개별 컴포넌트는 이 클래스가 호출.
[원칙] scoring_engine 자체는 비즈니스 로직 최소화 (단순 조율 역할)

class ScoringEngine:
    async def evaluate(self, request, user) -> ScoringResult:
        # 1. 신청자 유형 판별
        applicant_type = await self.classifier.classify(request)

        # 2. 하드컷 사전 검사 (모델 실행 전)
        pre_cut = self.hard_cut_engine.run_pre_checks(request)
        if pre_cut.rejected:
            explanations = self.explainer.hard_cut_to_korean(pre_cut.reason)
            return ScoringResult.rejected(pre_cut.reason, explanations)

        # 3. 피처 엔지니어링 (유형별 분기)
        features = self.feature_engineer.build(request, applicant_type)

        # 4. 모델 선택 + 추론
        model = self.model_registry.get_champion(applicant_type)
        pd_estimate = model.predict_proba(features)
        shap_values = self.shap_engine.compute_top5(model, features)

        # 5. 점수 스케일링 + 등급
        score = self.scaler.to_score(pd_estimate)
        grade = self.scaler.to_grade(score)

        # 6. 한도/금리 산출
        limit = self.limit_calculator.calculate(request, applicant_type)
        rate = self.pricing_engine.calculate_rate(grade, applicant_type)

        # 7. 하드컷 후처리 (최고금리 상한 등)
        post_cut = self.hard_cut_engine.run_post_checks(limit, rate)

        # 8. 설명 생성
        decision = self._make_decision(grade, post_cut)
        explanations = self.explainer.generate(shap_values, features,
                                                post_cut, decision)

        # 9. Shadow 챌린저 기록 (비동기, 응답 경로 외)
        asyncio.create_task(
            self.shadow_recorder.record(request, features, applicant_type)
        )

        return ScoringResult(
            applicant_type=applicant_type,
            credit_score=score, grade=grade, pd=pd_estimate,
            decision=decision, limit=post_cut.final_limit,
            rate=post_cut.final_rate, explanations=explanations,
        )
```

### 6.2 model_registry.py — 모델 버전 관리

```python
class ModelRegistry:
    """
    [FR-MDL-002] 코드 배포 없이 모델 교체 가능
    Champion/Challenger 버전 동시 관리
    """

    def __init__(self):
        self._champions: dict[str, LGBMClassifier] = {}
        self._challengers: dict[str, LGBMClassifier] = {}
        self._lock = asyncio.Lock()

    async def load_all(self, artifacts_path: str):
        """앱 시작 시 1회 모델 로딩 (요청마다 로딩 금지)"""
        model_types = [
            "application_salaried", "application_business",
            "application_pensioner", "behavioral", "collection"
        ]
        for model_type in model_types:
            path = f"{artifacts_path}/{model_type}/model.pkl"
            self._champions[model_type] = joblib.load(path)

    async def upload_challenger(self, model_type: str,
                                model_file: bytes) -> str:
        """
        [FR-MDL-001] 관리자 화면에서 챌린저 등록
        Shadow 모드 자동 활성화
        """
        async with self._lock:
            model = joblib.load(io.BytesIO(model_file))
            self._challengers[model_type] = model
            version_id = f"{model_type}_{datetime.now().strftime('%Y%m%d%H%M%S')}"
            await self._save_metadata(model_type, version_id, "challenger")
            return version_id

    async def promote_challenger(self, model_type: str):
        """챌린저 → 챔피언 승격 (리스크관리위원회 승인 후)"""
        async with self._lock:
            if model_type not in self._challengers:
                raise ValueError(f"챌린저 없음: {model_type}")
            # 현재 챔피언을 이전 버전으로 보관 (3세대 유지)
            await self._archive_champion(model_type)
            self._champions[model_type] = self._challengers.pop(model_type)

    async def rollback(self, model_type: str, version_id: str):
        """30초 이내 롤백 가능 (FR-MDL-001)"""
        async with self._lock:
            archived = await self._load_archived(model_type, version_id)
            self._champions[model_type] = archived
```

---

## 7. 데이터베이스 설계 계획

### 7.1 테이블 목록 및 설계 원칙

```
[15개 테이블 목록]

핵심 트랜잭션:
  applicants              ← 신청자 기본 정보
  loan_applications       ← 대출 신청
  credit_scores           ← 신용평가 결과
  audit_logs              ← 감사 로그 (INSERT ONLY)

참조 데이터:
  eq_grade_master         ← 고용주 EQ 등급 DB
  irg_mapping             ← KSIC → IRG 매핑 테이블
  regulation_params       ← 규제 파라미터 (동적 변경)
  grade_pd_map            ← 등급별 PD 테이블
  shap_templates          ← SHAP 한국어 변환 템플릿

운영/모니터링:
  model_versions          ← 모델 버전 이력
  shadow_results          ← 챌린저 Shadow 결과
  psi_snapshots           ← PSI 월별 스냅샷
  portfolio_snapshots     ← RAROC 월별 스냅샷
  alert_history           ← 경보 발령 이력

인증:
  users                   ← 사용자 (RBAC)
```

### 7.2 감사 로그 테이블 특수 설계

```sql
-- 감사 로그: INSERT ONLY, 수정/삭제 불가
-- 파티션: 월별 (성능 + 5년 보존 관리)
CREATE TABLE audit_logs (
    id              UUID DEFAULT gen_random_uuid(),
    event_type      VARCHAR(50)     NOT NULL,
    timestamp_ms    BIGINT          NOT NULL,  -- 밀리초 단위
    application_id  UUID,
    user_id         VARCHAR(100)    NOT NULL,
    user_role       VARCHAR(50)     NOT NULL,
    applicant_type  VARCHAR(30),
    credit_score    INTEGER,
    decision        VARCHAR(30),
    hard_cut_code   VARCHAR(50),
    dsr_ratio       DECIMAL(6,2),
    eq_grade        VARCHAR(5),
    irg_grade       VARCHAR(10),
    ip_address      INET,
    payload_hash    CHAR(64)        NOT NULL,  -- 무결성 검증용
    created_at      TIMESTAMPTZ     NOT NULL DEFAULT NOW()
) PARTITION BY RANGE (created_at);

-- 월별 파티션 자동 생성 (pg_partman 사용)
-- 5년 후 파티션 DROP 시 파기 증적 자동 기록

-- 수정/삭제 방지 트리거
CREATE RULE audit_logs_no_update AS ON UPDATE TO audit_logs DO INSTEAD NOTHING;
CREATE RULE audit_logs_no_delete AS ON DELETE TO audit_logs DO INSTEAD NOTHING;
```

### 7.3 규제 파라미터 테이블 설계

```sql
-- 배포 없이 실시간 변경 가능한 파라미터 저장소
CREATE TABLE regulation_params (
    param_key       VARCHAR(100)    PRIMARY KEY,
    param_value     JSONB           NOT NULL,   -- 다양한 타입 지원
    description     TEXT,
    changed_by      VARCHAR(100)    NOT NULL,
    change_reason   TEXT,
    effective_from  TIMESTAMPTZ     NOT NULL DEFAULT NOW(),
    previous_value  JSONB,                      -- 롤백용
    updated_at      TIMESTAMPTZ     NOT NULL DEFAULT NOW()
);

-- 초기값 예시
INSERT INTO regulation_params VALUES
('dsr_max_ratio',        '40.0',          'DSR 최대 한도 (%)', ...),
('base_rate',            '3.5',           '기준금리 (%)', ...),
('stress_dsr_metro',     '0.0075',        '수도권 스트레스 가산금리', ...),
('stress_dsr_non_metro', '0.0150',        '비수도권 스트레스 가산금리', ...),
('max_interest_rate',    '20.0',          '최고금리 상한 (%)', ...),
('eq_multipliers',       '{"EQ-S":2.0,"EQ-A":1.7,"EQ-B":1.5,...}', ...),
('irg_multipliers',      '{"IRG-L":1.3,"IRG-M":1.1,"IRG-H":0.9,...}', ...);
```

### 7.4 마이그레이션 전략

```
[Alembic 브랜치 전략]

main 브랜치: 운영 마이그레이션만
dev 브랜치: 개발 중 임시 마이그레이션

마이그레이션 파일 명명 규칙:
  {timestamp}_{jira_ticket}_{설명}.py
  예) 20260501_KCS_123_add_eq_grade_fields.py

롤백 원칙:
  모든 up() 함수에 반드시 down() 구현
  데이터 유실 마이그레이션은 사전 은행 IT 승인 필수
```

---

## 8. ML 파이프라인 상세 계획

### 8.1 학습 파이프라인 공통 구조 (base_trainer.py)

```python
class BaseScoreCardTrainer:
    """
    모든 Scorecard 학습의 공통 베이스 클래스
    유형별 학습 스크립트는 이 클래스를 상속하여 차이점만 구현
    """

    # 자식 클래스에서 반드시 정의
    MODEL_TYPE: str = NotImplemented
    TARGET_COLUMN: str = NotImplemented
    FEATURE_GROUPS: dict = NotImplemented
    MIN_OOT_GINI: float = NotImplemented

    def run(self, data_path: str, artifacts_dir: str):
        """표준 학습 파이프라인 (변경 금지)"""
        df = self.load_data(data_path)
        df_train, df_holdout, df_oot = self.time_split(df)

        # 1. WOE/IV 피처 선택
        selected_features, iv_report = self.select_features_by_iv(
            df_train, threshold=0.02
        )

        # 2. K-Fold CV 학습
        best_model, cv_metrics = self.train_with_cv(
            df_train[selected_features], df_train[self.TARGET_COLUMN]
        )

        # 3. 성능 검증
        metrics = self.evaluate_all_sets(
            best_model, selected_features,
            df_train, df_holdout, df_oot
        )

        # 4. 규제 검증 (실패 시 Exception)
        self.validate_regulatory(metrics)

        # 5. 공정성 검증
        fairness = self.validate_fairness(best_model, df_holdout,
                                          selected_features)

        # 6. SHAP 계산
        shap_importance = self.compute_shap(best_model, df_holdout,
                                             selected_features)

        # 7. PSI 계산
        psi = self.compute_psi(best_model, df_train, df_oot,
                               selected_features)

        # 8. 아티팩트 저장
        self.save_artifacts(
            artifacts_dir, best_model, iv_report,
            shap_importance, metrics, fairness, psi
        )

    def validate_regulatory(self, metrics: dict):
        """금감원 모범규준 위반 시 학습 실패 처리"""
        oot_gini = metrics["OOT"]["gini"]
        if oot_gini < self.MIN_OOT_GINI:
            raise RegulatoryValidationError(
                f"OOT Gini {oot_gini:.4f} < 최소 기준 {self.MIN_OOT_GINI}"
                " — 모델 재개발 필요"
            )
```

### 8.2 직장인 Application Scorecard 특화 피처

```python
class SalariedApplicationTrainer(BaseScoreCardTrainer):
    MODEL_TYPE = "application_salaried"
    TARGET_COLUMN = "default_12m"  # 90일 이상 연체 발생
    MIN_OOT_GINI = 0.30

    FEATURE_GROUPS = {
        "credit_history": [          # 가장 중요
            "cb_score", "delinquency_count_12m", "delinquency_count_24m",
            "worst_delinquency_status", "open_loan_count",
            "inquiry_count_3m", "inquiry_count_6m", "credit_card_count",
        ],
        "employer_quality": [        # 직장인 고유
            "eq_grade_score",        # EQ-S=100, E=15 변환값
            "employment_stability",  # 근속×계약유형×EQ 복합 지수
            "income_reliability",    # 소득 검증 신뢰도
        ],
        "occupation": [              # 직종 안정성
            "osi_score",             # OSI 지수 0.8~1.3
        ],
        "financial_ratio": [
            "dsr_ratio", "debt_to_income", "loan_to_income",
        ],
        "transaction": [
            "savings_rate", "card_usage_rate", "overdraft_count_annual",
        ],
        "alternative": [
            "telecom_no_delinquency", "health_insurance_paid_months_12m",
            "national_pension_paid_months_24m",
        ],
    }

    # 민감 변수 직접 사용 금지 (금융위 AI 가이드라인)
    EXCLUDED_FEATURES = ["age_raw", "gender", "residence_district"]
```

### 8.3 PSI 3종 계산 구현

```python
class PSICalculator:
    """
    [FR-MON-002] PSI 3종 월별 자동 계산
    """

    def calc_score_psi(self, period: str) -> float:
        """Score PSI: 예측 확률 분포 변화"""
        baseline = self._get_baseline_scores()   # 학습 기간
        current = self._get_current_scores(period)  # 이번 달
        return self._compute_psi(baseline, current, bins=10)

    def calc_feature_psi(self, period: str) -> dict[str, float]:
        """Feature PSI: 상위 IV 피처별 분포 변화"""
        top_features = ["cb_score", "dsr_ratio", "inquiry_count_3m",
                        "delinquency_count_12m", "eq_grade_score"]
        return {
            feat: self._compute_feature_psi(feat, period)
            for feat in top_features
        }

    def calc_target_psi(self, period: str) -> float:
        """Target PSI: 실제 부도율 변화"""
        baseline_br = self._get_baseline_bad_rate()
        current_br = self._get_current_bad_rate(period)
        diff = abs(current_br - baseline_br)
        # ±2.5%p 초과 시 경보
        return diff

    def _compute_psi(self, expected: np.ndarray,
                     actual: np.ndarray, bins: int = 10) -> float:
        bins_arr = np.percentile(expected, np.linspace(0, 100, bins + 1))
        bins_arr = np.unique(bins_arr)
        exp_hist = np.histogram(expected, bins=bins_arr)[0]
        act_hist = np.histogram(actual, bins=bins_arr)[0]
        # 0 방지 (0.5 스무딩)
        exp_pct = (exp_hist + 0.5) / (exp_hist.sum() + 0.5 * len(exp_hist))
        act_pct = (act_hist + 0.5) / (act_hist.sum() + 0.5 * len(act_hist))
        return float(np.sum((act_pct - exp_pct) * np.log(act_pct / exp_pct)))
```

---

## 9. 외부 연동 구현 계획

### 9.1 연동 우선순위 및 일정

| 외부 시스템 | 중요도 | 구현 Sprint | 연동 방식 | 장애 처리 |
|-----------|------|-----------|---------|---------|
| CB (나이스/KCB) | 최고 | Sprint 10 | REST API | 3회 재시도 → 수동심사 |
| CBS | 최고 | Sprint 10 | 내부 API | Fallback: 캐시 사용 |
| 기업신용정보 (NICE/KED) | 높음 | Sprint 11 | REST API | Fallback: EQ-D 기본 |
| 국세청 홈택스 | 높음 | Sprint 11 | 공공 API | Fallback: 수동 서류 |
| 건강보험공단 | 중간 | Sprint 11 | 공공 API | Fallback: 자기신고 |
| 국민연금공단 | 중간 | Sprint 12 | 공공 API | Fallback: 자기신고 |
| 금융결제원 오픈뱅킹 | 낮음 | Sprint 13 | REST API | 선택적 연동 |

### 9.2 외부 연동 공통 패턴

```python
class ExternalAPIClient:
    """모든 외부 API 클라이언트의 기반 클래스"""

    def __init__(self, base_url: str, timeout: float = 2.0,
                 max_retries: int = 3):
        self.base_url = base_url
        self.timeout = timeout
        self.max_retries = max_retries
        self.session: aiohttp.ClientSession = None

    async def request_with_retry(self, method: str, path: str,
                                  **kwargs) -> dict:
        last_exc = None
        for attempt in range(self.max_retries):
            try:
                async with asyncio.timeout(self.timeout):
                    async with self.session.request(
                        method, f"{self.base_url}{path}", **kwargs
                    ) as resp:
                        resp.raise_for_status()
                        return await resp.json()
            except Exception as e:
                last_exc = e
                wait = 1.0 * (attempt + 1)  # 지수 백오프
                await asyncio.sleep(wait)

        # 모든 재시도 실패 → 상위 레이어에서 Fallback 처리
        raise ExternalAPIException(
            f"{self.__class__.__name__} 연동 실패 ({self.max_retries}회)",
            cause=last_exc
        )
```

---

## 10. 보안 구현 계획

### 10.1 보안 구현 일정

| 보안 항목 | Sprint | 구현 내용 | 검증 방법 |
|---------|--------|---------|---------|
| HMAC-SHA256 주민번호 해시 | 5 | crypto.py 구현 | 단위 테스트 |
| AES-256-GCM 계좌번호 암호화 | 5 | crypto.py 구현 | 단위 테스트 |
| JWT RS256 인증 | 9 | jwt_handler.py | 위변조 침투 테스트 |
| RBAC 구현 | 9 | rbac.py 전체 | TC-SEC-003 |
| Rate Limiting (Nginx) | 11 | Nginx 설정 | 부하 테스트 |
| TLS 1.3 전용 | 12 | Nginx 설정 | SSL Labs A+ |
| 보안 정적 분석 (Bandit) | CI | GitHub Actions | 매 PR |
| 제3자 침투 테스트 | Phase 4 | 외부 기관 | 결과 보고서 |

### 10.2 개인정보 처리 안전 코드 원칙

```python
# [금지] 개인정보 로그 출력
logger.info(f"신청자 주민번호: {resident_number}")  # ← 절대 금지

# [권장] ID만 로그
logger.info(f"신청 처리: application_id={application_id}")

# [금지] 응답에 개인정보 원문 포함
return {"resident_number": resident_number}  # ← 절대 금지

# [권장] 마스킹 또는 해시만 반환
return {"resident_hash": crypto.hash_resident_number(resident_number)}

# [금지] SQL f-string 직접 삽입
query = f"SELECT * FROM applicants WHERE id = '{user_input}'"  # ← 금지

# [권장] 파라미터 바인딩
result = await db.execute(
    select(Applicant).where(Applicant.id == applicant_id)
)
```

---

## 11. 테스트 실행 계획

### 11.1 테스트 자동화 파이프라인

```yaml
# .github/workflows/test.yml
name: Test Pipeline

on: [push, pull_request]

jobs:
  unit-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Unit Tests + Coverage
        run: |
          pytest tests/unit/ -v --cov=app --cov-fail-under=80

  regulatory-test:
    runs-on: ubuntu-latest
    needs: unit-test
    steps:
      - name: Regulatory Compliance Tests
        run: |
          pytest tests/regulatory/ -v -s --tb=long \
            --exitfirst \  # 1건 실패 시 즉시 중단
            --html=reports/regulatory_$(date +%Y%m%d).html

  security-scan:
    runs-on: ubuntu-latest
    steps:
      - name: Bandit Security Scan
        run: bandit -r backend/app/ -ll --exit-zero
      - name: Dependency Vulnerability Check
        run: safety check -r backend/requirements.txt

  lint:
    runs-on: ubuntu-latest
    steps:
      - name: Ruff Lint
        run: ruff check backend/app/
      - name: Mypy Type Check
        run: mypy backend/app/ --ignore-missing-imports
```

### 11.2 규제 준수 테스트 구현 예시

```python
# tests/regulatory/test_dsr_hard_cut.py
"""
TC-REG-001~005: DSR 하드컷 자동화 테스트
[FR-REG-001] 스트레스 DSR > 40% → 승인 불가
"""
import pytest
from decimal import Decimal

class TestDSRHardCut:

    @pytest.mark.parametrize("dsr,expected_pass", [
        (39.9, True),   # TC-REG-001: 정상 범위
        (40.0, False),  # TC-REG-002: 경계값 (초과로 처리)
        (40.1, False),  # TC-REG-003: 초과
        (80.0, False),  # TC-REG-004: 극단값
    ])
    def test_dsr_hard_cut_boundary(self, hard_cut_engine, request_factory,
                                   dsr: float, expected_pass: bool):
        """경계값 테스트 포함 — SI 업체가 40.0% 처리를 누락하는 것 방지"""
        request = request_factory.build(dsr_ratio=dsr)
        result = hard_cut_engine.check_stress_dsr(request)
        assert result.passed == expected_pass, (
            f"DSR={dsr}%: 기대={expected_pass}, 실제={result.passed}"
            f"\n사유: {result.reject_code}"
        )

    def test_dsr_zero_income(self, hard_cut_engine, request_factory):
        """TC-REG-005: 소득=0 (분모=0) 예외 처리"""
        request = request_factory.build(monthly_income=0)
        result = hard_cut_engine.check_stress_dsr(request)
        # 소득 0인 경우 자동 승인 불가, 수동심사 이관
        assert not result.passed
        assert result.reject_code in ["DSR_EXCEED", "INCOME_ZERO"]

    def test_dsr_limit_reduction(self, hard_cut_engine, request_factory):
        """DSR 초과 시 한도 축소 제안 금액 검증"""
        # 월소득 400만원, 기존 원리금 100만원, 신규 신청 → DSR 50%
        request = request_factory.build(
            monthly_income=4_000_000,
            existing_monthly_payment=1_000_000,
            requested_amount=200_000_000,  # 2억 (DSR 크게 초과)
        )
        result = hard_cut_engine.check_stress_dsr(request)
        assert not result.passed
        # 역산 한도가 0보다 크면 한도 축소 제안 가능
        if result.reduced_amount > 0:
            # 역산 한도로 재계산 시 DSR ≤ 40% 확인
            reduced_request = request_factory.build(
                monthly_income=4_000_000,
                existing_monthly_payment=1_000_000,
                requested_amount=result.reduced_amount,
            )
            reduced_result = hard_cut_engine.check_stress_dsr(reduced_request)
            assert reduced_result.passed, "역산 한도도 DSR 초과 — 계산 오류"
```

---

## 12. 배포 및 운영 이관 계획

### 12.1 Blue-Green 배포 전략

```
[배포 흐름]
현재 Blue(운영) → Green(신버전 배포)
  ① Green 환경에 신버전 배포
  ② Green 헬스체크 통과 확인 (5분)
  ③ Nginx upstream을 Blue → Green으로 전환 (무중단)
  ④ Blue는 30분간 대기 (롤백 준비)
  ⑤ 이상 없으면 Blue 종료

[롤백 절차]
  이상 감지 시 → Nginx upstream을 Green → Blue로 즉시 전환
  전환 시간: 5초 이내
  자동 롤백 트리거: P1 에러율 5% 초과 시 자동 Blue 복귀
```

### 12.2 운영 이관 체크리스트

```
[운영 전환 D-5]
□ 운영 환경 최종 보안 점검 완료
□ DR 사이트 페일오버 테스트 성공
□ 운영 CB API 인증 키 적용 확인
□ Kafka Consumer 그룹 운영값 설정
□ Grafana 알림 수신자(리스크팀, IT팀) 등록

[운영 전환 D-1]
□ 현업 대기 연락망 확인 (야간 비상 연락처)
□ 롤백 절차 최종 리허설
□ 전환 직전 DB 스냅샷 백업

[운영 전환 Day]
□ 트래픽 전환 (Blue-Green)
□ 첫 실제 신청 건 처리 모니터링 (30분)
□ 감사 로그 정상 수집 확인
□ CB API 실제 조회 성공 확인
```

---

## 13. 리스크 관리 계획

### 13.1 주요 리스크 식별 및 대응

| ID | 리스크 | 발생 가능성 | 영향도 | 대응 방안 |
|----|--------|-----------|-------|---------|
| R-01 | CB API Sandbox 계약 지연 | 중 | 높음 | Mock CB API 서버로 개발 진행, 실계약 병렬 추진 |
| R-02 | OOT Gini 목표 미달 | 중 | 높음 | 합성 데이터 품질 개선, 피처 추가, 알고리즘 교체 예비 계획 |
| R-03 | 성능 목표(500ms) 미달 | 낮음 | 중간 | SHAP 근사 계산, Redis 캐싱 강화, 서버 사양 증설 옵션 |
| R-04 | 규제 변경 (DSR, LTV 한도) | 중 | 높음 | 파라미터 동적 관리로 배포 없이 즉시 대응 |
| R-05 | 핵심 인력 이탈 (ML 리드) | 낮음 | 높음 | 모든 코드 문서화 의무화, 2인 이상 지식 공유 |
| R-06 | 국세청 API 연동 실패 | 중 | 중간 | Fallback: 수동 서류 제출로 대체, API는 Phase 2로 이연 |
| R-07 | UAT 합격률 미달 | 중 | 높음 | 현업과 스프린트마다 중간 리뷰, 조기 피드백 반영 |
| R-08 | 개인정보 유출 사고 | 매우 낮음 | 매우 높음 | 개발 환경 실데이터 금지, 단계별 보안 점검 |

### 13.2 일정 예비비 계획

```
[일정 버퍼 배분]

Phase별 예비비:
  Phase 0 (기반): 0주 (고정)
  Phase 1 (ML):   2주 (모델 성능 미달 시 재학습)
  Phase 2 (백엔드): 1주
  Phase 3 (API):  1주
  Phase 4 (보안): 2주 (보안 취약점 수정 시간)
  Phase 5 (테스트): 2주 (규제 테스트 실패 수정)
  Phase 6 (이관):  1주

총 예비비: 9주 (전체 일정의 17%)
→ 최악 시나리오: 2027-05-28까지 완료 가능
```

---

## 14. WBS 및 마일스톤

### 14.1 전체 일정표

```
[2026-2027 개발 일정]

2026년
4월  [Phase 0] ████████ 착수·기반·DB 스키마
5월  [Phase 1] ████████ ML - Application Scorecard
6월  [Phase 1] ████████ ML - Behavioral/Collection + 검증체계
          │
          ▼ 품질 게이트 1 (ML 전체 모델 OOT Gini 통과)
7월  [Phase 2] ████████ 백엔드 - 규제 엔진 + 유형 판별
8월  [Phase 2] ████████ 백엔드 - 한도/금리 + 설명 엔진 + 감사로그
          │
          ▼ 품질 게이트 2 (TC-REG 전건 통과)
9월  [Phase 3] ████████ API - 핵심 엔드포인트 + RBAC
10월 [Phase 3] ████ API 완성
     [Phase 4] ████ 보안 구현
          │
          ▼ 품질 게이트 3 (보안 취약점 0건)
11월 [Phase 5] ████████ 통합 테스트 (규제/성능)
12월 [Phase 5] ████ UAT
     [Phase 6] ████ 운영 이관 착수

2027년
1월  [Phase 6] ████████ 운영 이관 완료 + 소프트 런치
2월  [Phase 7] ████████ 안정화 1개월
3월  [Phase 7] ████████ 안정화 2개월
4월  [Phase 7] ████████ 안정화 3개월 → 최종 검수 완료
```

### 14.2 마일스톤 및 대금 지급 기준

| 마일스톤 | 일정 | 완료 기준 | 대금 |
|---------|------|---------|------|
| M1: 착수 완료 | 2026-04-30 | DB 마이그레이션 성공, CB Sandbox 연결 | 10% |
| M2: ML 파이프라인 완료 | 2026-06-26 | 전체 모델 OOT Gini 통과, 4역할 검증 완료 | 15% |
| M3: 백엔드 코어 완료 | 2026-08-21 | TC-REG 전건 통과, 단위 테스트 80%+ | 15% |
| M4: 전체 개발 완료 | 2026-10-30 | API 완성, 보안 취약점 0건 | 20% |
| M5: 검증 완료 | 2026-12-11 | 통합 테스트 + UAT 합격 | 20% |
| M6: 운영 이관 | 2027-01-09 | 운영 배포, KT 완료, 현업 사용 시작 | 10% |
| M7: 안정화 완료 | 2027-04-10 | 3개월 P1 장애 0건, SLA 99.9% | 10% |

---

## 15. 품질 관리 계획

### 15.1 코드 품질 자동화 지표

```
[매 PR 자동 측정]
  단위 테스트 커버리지 ≥ 80%        (pytest-cov)
  린트 오류 0건                      (ruff)
  타입 오류 0건                      (mypy)
  보안 정적 분석 High+ 0건           (bandit)
  규제 준수 테스트 전건 통과          (pytest tests/regulatory/)

[주간 자동 측정]
  통합 테스트 전건 통과
  성능 회귀 테스트 (P95 ≤ 400ms)
  취약 의존성 스캔 (safety check)
```

### 15.2 산출물 품질 기준

| 산출물 | 품질 기준 | 검토 주체 |
|--------|---------|---------|
| 코드 | PR 2인 리뷰 + 자동 테스트 통과 | 개발팀 |
| 모델 | OOT Gini + PSI + 공정성 전항목 통과 | ML 엔지니어 + 리스크팀 |
| DB 스키마 | ERD 검토 + 마이그레이션 성공 | DB 엔지니어 + 은행 IT |
| API 명세 | Swagger 자동 생성 + 현업 리뷰 | 백엔드 + 은행 현업 |
| 보안 | 제3자 기관 보안 진단 통과 | 보안 전문가 + 은행 보안팀 |
| 운영 매뉴얼 | KT 체크리스트 전항목 통과 | DevOps + 은행 IT |

---

*본 문서는 KCS-SRS-2026-001 (상세 요건 정의서 v1.0)을 기반으로 작성되었습니다.*
*v1.0 기준일: 2026-02-27*
*다음 개정: Phase 0 완료 후 세부 일정 확정 시 (v1.1)*
